{
  if (tagid.isEmpty()) {
    throw new WebApplicationException();
  }
  if (feed.getAtmosphereResources().size() == 0) {
    final Future<?> future=feed.scheduleFixedBroadcast(new Callable<String>(){
      private final AtomicReference<String> refreshUrl=new AtomicReference<String>("");
      public String call() throws Exception {
        String query=null;
        if (!refreshUrl.get().isEmpty()) {
          query=refreshUrl.get();
        }
 else {
          query="?q=" + tagid;
        }
        suspendLatch.await();
        asyncClient.prepareGet("http://search.twitter.com/search.json" + query).execute(new AsyncCompletionHandler<Object>(){
          @Override public Object onCompleted(          Response response) throws Exception {
            String s=response.getResponseBody();
            if (response.getStatusCode() != 200) {
              feed.resumeAll();
              feed.destroy();
              logger.info("Twitter Search API unavaileble\n{}",s);
              return null;
            }
            JSONObject json=new JSONObject(s);
            refreshUrl.set(json.getString("refresh_url"));
            if (json.getJSONArray("results").length() > 1) {
              feed.broadcast(s).get();
            }
            return null;
          }
        }
);
        return null;
      }
    }
,1,TimeUnit.HOURS);
    futures.put(tagid,future);
  }
  return new SuspendResponse.SuspendResponseBuilder<String>().broadcaster(feed).outputComments(true).addListener(new EventsLogger(){
    @Override public void onSuspend(    final AtmosphereResourceEvent event){
      super.onSuspend(event);
      suspendLatch.countDown();
    }
  }
).build();
}
