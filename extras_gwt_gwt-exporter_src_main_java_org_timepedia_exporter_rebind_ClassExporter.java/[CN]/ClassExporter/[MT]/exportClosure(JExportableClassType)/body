{
  if (requestedType == null) {
    logger.log(TreeLogger.ERROR,"Type '" + requestedType.getQualifiedSourceName() + "' does not implement Exportable",null);
    throw new UnableToCompleteException();
  }
  String genName=requestedType.getExporterImplementationName();
  sw.indent();
  sw.println("private " + ExportableTypeOracle.JSO_CLASS + " jso;");
  sw.println();
  sw.println("public " + genName + "() { export(); }");
  sw.println("public " + genName + "("+ ExportableTypeOracle.JSO_CLASS+ " jso) {");
  sw.indent();
  sw.println("this.jso = jso;");
  if (requestedType.isStructuralType()) {
    sw.println("___importStructuralType();");
  }
  sw.outdent();
  sw.println("}");
  sw.println();
  sw.println("public static " + genName + " makeClosure("+ ExportableTypeOracle.JSO_CLASS+ " closure) {");
  sw.indent();
  sw.println("return new " + genName + "(closure);");
  sw.outdent();
  sw.println("}");
  sw.println();
  JExportableMethod[] methods=requestedType.getExportableMethods();
  if (methods.length != 1) {
    logger.log(TreeLogger.ERROR,"Interface " + requestedType.getQualifiedSourceName() + " has more than one "+ "declared method. @gwt.exportClosure only currently works for "+ "single method interfaces.",null);
    throw new UnableToCompleteException();
  }
  JExportableMethod method=methods[0];
  JExportableType retType=method.getExportableReturnType();
  if (retType == null) {
    logger.log(TreeLogger.ERROR,"Return type of method " + method + " is not exportable.",null);
    throw new UnableToCompleteException();
  }
  if (retType.needsExport() && !exported.contains(retType.getQualifiedSourceName())) {
    if (exportDependentClass(retType.getQualifiedSourceName())) {
      exported.add((JExportableClassType)retType);
    }
  }
  exportDependentParams(method);
  boolean isVoid=retType.getQualifiedSourceName().equals("void");
  boolean noParams=method.getExportableParameters().length == 0;
  sw.print("public " + method.getExportableReturnType().getQualifiedSourceName());
  sw.print(" " + method.getName() + "(");
  declareParameters(method,-1,true);
  sw.println(") {");
  sw.indent();
  sw.print((isVoid ? "" : "return ") + "invoke(jso" + (noParams ? "" : ","));
  declareJavaPassedValues(method,false);
  sw.println(");");
  sw.outdent();
  sw.println("}");
  sw.println();
  sw.print("public native " + (isVoid ? "void" : method.getExportableReturnType().getQualifiedSourceName()));
  sw.print(" invoke(" + ExportableTypeOracle.JSO_CLASS + " closure");
  if (method.getExportableParameters().length > 0) {
    sw.print(", ");
  }
  declareParameters(method,-1,true);
  sw.println(") /*-{");
  sw.indent();
  sw.print((!isVoid ? "var result= " : "") + "closure(");
  declareJavaPassedValues(method,true);
  sw.println(");");
  boolean isArray=retType instanceof JExportableArrayType;
  if (retType.needsExport() && !isVoid && !isArray) {
    sw.println("if(result != null && result != undefined) " + "result=result.instance;");
    sw.println("else if(result == undefined) result=null;");
  }
  if (!isVoid) {
    sw.println("return result;");
  }
  sw.outdent();
  sw.println("}-*/;");
  sw.println();
  sw.outdent();
}
