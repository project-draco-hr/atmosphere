{
  if (destroyed.get())   throw new IllegalStateException("This Broadcaster has been destroyed and cannot be used");
  final Object msg=filter(o);
  if (msg == null)   return null;
  final BroadcasterFuture<Object> future=new BroadcasterFuture<Object>(msg);
  final Entry e=new Entry(msg,null,future,o);
  Future<T> f;
  if (delay > 0) {
    f=bc.getScheduledExecutorService().schedule(new Callable<T>(){
      public T call() throws Exception {
        delayedBroadcast.remove(e);
        if (Callable.class.isAssignableFrom(o.getClass())) {
          try {
            Object r=Callable.class.cast(o).call();
            final Object msg=filter(r);
            if (msg != null) {
              Entry entry=new Entry(msg,null,null,r);
              push(entry);
            }
            return (T)msg;
          }
 catch (          Exception e1) {
            logger.error("",e);
          }
        }
        final Object msg=filter(o);
        final Entry e=new Entry(msg,null,null,o);
        push(e);
        return (T)msg;
      }
    }
,delay,t);
    e.future=new BroadcasterFuture<Object>(f,msg);
  }
  delayedBroadcast.offer(e);
  return future;
}
