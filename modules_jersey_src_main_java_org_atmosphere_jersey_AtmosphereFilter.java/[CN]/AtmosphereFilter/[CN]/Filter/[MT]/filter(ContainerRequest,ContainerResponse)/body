{
  if (response.getMappedThrowable() != null) {
    return response;
  }
  AtmosphereResource<HttpServletRequest,HttpServletResponse> r=(AtmosphereResource<HttpServletRequest,HttpServletResponse>)servletReq.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);
  if (Boolean.parseBoolean((String)servletReq.getAttribute(ApplicationConfig.SUPPORT_LOCATION_HEADER))) {
    useResumeAnnotation=true;
  }
switch (action) {
case ASYNCHRONOUS:
    if (response.getStatus() == 204) {
      response.setStatus(200);
    }
  String transport=servletReq.getHeader(X_ATMOSPHERE_TRANSPORT);
if (transport == null) {
  throw new WebApplicationException(new IllegalStateException("Must specify transport using header value " + X_ATMOSPHERE_TRANSPORT));
}
String subProtocol=(String)servletReq.getAttribute(FrameworkConfig.WEBSOCKET_SUBPROTOCOL);
String broadcasterName=servletReq.getHeader(topic);
final boolean waitForResource=waitFor == -1 ? true : false;
final Broadcaster bcaster=BroadcasterFactory.getDefault().lookup(broadcasterName,true);
if (!transport.startsWith(POLLING_TRANSPORT) && subProtocol == null) {
boolean outputJunk=transport.equalsIgnoreCase(STREAMING_TRANSPORT);
final boolean resumeOnBroadcast=resumeOnBroadcast(request,false);
for (Class<? extends AtmosphereResourceEventListener> listener : listeners) {
try {
AtmosphereResourceEventListener el=listener.newInstance();
InjectorProvider.getInjector().inject(el);
if (r instanceof AtmosphereEventLifecycle) {
r.addEventListener(el);
}
}
 catch (Throwable t) {
throw new WebApplicationException(new IllegalStateException("Invalid AtmosphereResourceEventListener " + listener));
}
}
final Object entity=response.getEntity();
r.addEventListener(new AtmosphereResourceEventListenerAdapter(){
@Override public void onSuspend(AtmosphereResourceEvent<HttpServletRequest,HttpServletResponse> event){
try {
if (entity != null) {
if (waitForResource) {
  bcaster.awaitAndBroadcast(entity,30,TimeUnit.SECONDS);
}
 else {
  bcaster.broadcast(entity);
}
}
}
  finally {
event.getResource().removeEventListener(this);
}
}
}
);
if (resumeOnBroadcast) {
servletReq.setAttribute(ApplicationConfig.RESUME_ON_BROADCAST,new Boolean(true));
}
r.setBroadcaster(bcaster);
executeSuspend(r,timeout,outputJunk,resumeOnBroadcast,null,request,response,false);
}
 else {
Object entity=response.getEntity();
if (waitForResource) {
bcaster.awaitAndBroadcast(entity,30,TimeUnit.SECONDS);
}
 else {
bcaster.broadcast(entity);
}
if (subProtocol == null) {
try {
if (Callable.class.isAssignableFrom(entity.getClass())) {
entity=Callable.class.cast(entity).call();
}
response.setEntity(entity);
response.write();
}
 catch (Throwable t) {
logger.debug("Error running Callable",t);
response.setEntity(null);
}
}
 else {
response.setEntity(null);
}
}
break;
case SUSPEND_RESPONSE:
SuspendResponse<?> s=SuspendResponse.class.cast(JResponseAsResponse.class.cast(response.getResponse()).getJResponse());
boolean outputJunk=outputJunk(request,s.outputComments());
boolean resumeOnBroadcast=resumeOnBroadcast(request,s.resumeOnBroadcast());
for (AtmosphereResourceEventListener el : s.listeners()) {
if (r instanceof AtmosphereEventLifecycle) {
r.addEventListener(el);
}
}
Broadcaster bc=s.broadcaster();
if (bc == null && s.scope() != Suspend.SCOPE.REQUEST) {
bc=(Broadcaster)servletReq.getAttribute(INJECTED_BROADCASTER);
}
boolean supportTrackable=servletReq.getAttribute(ApplicationConfig.SUPPORT_TRACKABLE) != null;
boolean isTracked=response.getEntity() != null ? TrackableResource.class.isAssignableFrom(response.getEntity().getClass()) : supportTrackable;
TrackableResource<? extends Trackable> trackableResource=null;
if (isTracked) {
trackableResource=preTrack(request,response);
}
suspend(resumeOnBroadcast,outputJunk,translateTimeUnit(s.period().value(),s.period().timeUnit()),request,response,bc,r,s.scope());
if (isTracked && trackableResource != null) {
postTrack(trackableResource,r);
}
break;
case SUBSCRIBE_TRACKABLE:
case SUBSCRIBE:
case SUSPEND:
case SUSPEND_TRACKABLE:
case SUSPEND_RESUME:
outputJunk=outputJunk(request,outputComments);
resumeOnBroadcast=resumeOnBroadcast(request,(action == Action.SUSPEND_RESUME));
for (Class<? extends AtmosphereResourceEventListener> listener : listeners) {
try {
AtmosphereResourceEventListener el=listener.newInstance();
InjectorProvider.getInjector().inject(el);
if (r instanceof AtmosphereEventLifecycle) {
((AtmosphereEventLifecycle)r).addEventListener(el);
}
}
 catch (Throwable t) {
throw new WebApplicationException(new IllegalStateException("Invalid AtmosphereResourceEventListener " + listener,t));
}
}
Broadcaster broadcaster=(Broadcaster)servletReq.getAttribute(INJECTED_BROADCASTER);
if (action == Action.SUBSCRIBE) {
Class<Broadcaster> c=null;
try {
c=(Class<Broadcaster>)Class.forName((String)servletReq.getAttribute(ApplicationConfig.BROADCASTER_CLASS));
}
 catch (Throwable e) {
throw new IllegalStateException(e.getMessage());
}
broadcaster=BroadcasterFactory.getDefault().lookup(c,topic,true);
}
supportTrackable=servletReq.getAttribute(ApplicationConfig.SUPPORT_TRACKABLE) != null;
isTracked=response.getEntity() != null ? TrackableResource.class.isAssignableFrom(response.getEntity().getClass()) : supportTrackable;
if (isTracked) {
trackableResource=preTrack(request,response);
}
 else {
trackableResource=null;
}
suspend(resumeOnBroadcast,outputJunk,timeout,request,response,broadcaster,r,scope);
if (isTracked && trackableResource != null) {
postTrack(trackableResource,r);
}
break;
case RESUME:
if (response.getEntity() != null) {
try {
response.write();
}
 catch (IOException ex) {
throw new WebApplicationException(ex);
}
}
boolean sessionSupported=(Boolean)servletReq.getAttribute(FrameworkConfig.SUPPORT_SESSION);
if (sessionSupported) {
r=(AtmosphereResource)servletReq.getSession().getAttribute(SUSPENDED_RESOURCE);
}
 else {
String path=response.getContainerRequest().getPath();
r=resumeCandidates.remove(path.substring(path.lastIndexOf("/") + 1));
}
if (r != null) {
resume(r);
}
 else {
throw new WebApplicationException(new IllegalStateException("Unable to retrieve suspended Response. " + "Either session-support is not enabled in atmosphere.xml or the" + "path used to resume is invalid."));
}
break;
case BROADCAST:
case PUBLISH:
case RESUME_ON_BROADCAST:
AtmosphereResource ar=(AtmosphereResource)servletReq.getAttribute(SUSPENDED_RESOURCE);
if (ar != null) {
r=ar;
}
if (action == Action.PUBLISH) {
Class<Broadcaster> c=null;
try {
c=(Class<Broadcaster>)Class.forName((String)servletReq.getAttribute(ApplicationConfig.BROADCASTER_CLASS));
}
 catch (Throwable e) {
throw new IllegalStateException(e.getMessage());
}
r.setBroadcaster(BroadcasterFactory.getDefault().lookup(c,topic,true));
}
broadcast(response,r,timeout);
break;
case SCHEDULE:
case SCHEDULE_RESUME:
Object o=response.getEntity();
Broadcaster b=r.getBroadcaster();
if (response.getEntity() instanceof Broadcastable) {
b=((Broadcastable)response.getEntity()).getBroadcaster();
o=((Broadcastable)response.getEntity()).getMessage();
response.setEntity(((Broadcastable)response.getEntity()).getResponseMessage());
}
if (response.getEntity() != null) {
try {
response.write();
}
 catch (IOException ex) {
throw new WebApplicationException(ex);
}
}
if (action == Action.SCHEDULE_RESUME) {
configureResumeOnBroadcast(b);
}
b.scheduleFixedBroadcast(o,waitFor,timeout,TimeUnit.SECONDS);
break;
}
return response;
}
