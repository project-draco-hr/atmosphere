{
  boolean writeAsBytes=IOUtils.isBodyBinary(response.request());
  if (writeAsBytes) {
    logger.warn("Cannot use TrackMessageSizeInterceptor with binary write. Writing the message as it is.");
    return responseDraft;
  }
  if (response.request().getAttribute(SKIP_INTERCEPTOR) == null && (response.getContentType() == null || !excludedContentTypes.contains(response.getContentType().toLowerCase()))) {
    response.setCharacterEncoding(OUT_ENCODING);
    CharBuffer cb=inCharset.newDecoder().decode(ByteBuffer.wrap(responseDraft,0,responseDraft.length));
    String s=cb.toString();
    if (s.trim().length() == 0) {
      return responseDraft;
    }
    int size=cb.length();
    if (response.resource().transport().equals(AtmosphereResource.TRANSPORT.JSONP) && data.length != responseDraft.length) {
      size=inCharset.newDecoder().decode(ByteBuffer.wrap(data,0,data.length)).length();
    }
    CharBuffer cb2=CharBuffer.wrap(Integer.toString(size) + endString);
    ByteBuffer bb=ByteBuffer.allocate((cb2.length() + size) * 2);
    CharsetEncoder encoder=outCharset.newEncoder();
    encoder.encode(cb2,bb,false);
    encoder.encode(cb,bb,false);
    bb.flip();
    byte[] b=new byte[bb.limit()];
    bb.get(b);
    return b;
  }
 else {
    return responseDraft;
  }
}
