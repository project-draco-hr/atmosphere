{
  String s=config.getInitParameter(ApplicationConfig.BROADCASTER_SHARABLE_THREAD_POOLS);
  if (Boolean.parseBoolean(s)) {
    isExecutorShared=true;
    isAsyncExecutorShared=true;
  }
  if (config.properties().get("executorService") == null) {
    int numberOfMessageProcessingThread=-1;
    s=config.getInitParameter(ApplicationConfig.BROADCASTER_MESSAGE_PROCESSING_THREADPOOL_MAXSIZE);
    if (s != null) {
      numberOfMessageProcessingThread=Integer.parseInt(s);
    }
    if (isExecutorShared && numberOfMessageProcessingThread == 1) {
      logger.warn("Not enough numberOfMessageProcessingThread for a shareable thread pool {}, " + "Setting it to a newCachedThreadPool",numberOfMessageProcessingThread);
      numberOfMessageProcessingThread=-1;
    }
    int numberOfAsyncThread=-1;
    s=config.getInitParameter(ApplicationConfig.BROADCASTER_ASYNC_WRITE_THREADPOOL_MAXSIZE);
    if (s != null) {
      numberOfAsyncThread=Integer.parseInt(s);
    }
    if (isAsyncExecutorShared && numberOfAsyncThread == 1) {
      logger.warn("Not enough numberOfAsyncThread for a shareable thread pool {}, " + "Setting it to a newCachedThreadPool",numberOfAsyncThread);
      numberOfAsyncThread=-1;
    }
    if (numberOfMessageProcessingThread == -1) {
      executorService=Executors.newCachedThreadPool(new ThreadFactory(){
        private final AtomicInteger count=new AtomicInteger();
        @Override public Thread newThread(        final Runnable runnable){
          Thread t=new Thread(runnable,"Atmosphere-BroadcasterConfig-" + count.getAndIncrement());
          t.setDaemon(true);
          return t;
        }
      }
);
    }
 else {
      executorService=Executors.newFixedThreadPool(numberOfMessageProcessingThread,new ThreadFactory(){
        private final AtomicInteger count=new AtomicInteger();
        @Override public Thread newThread(        final Runnable runnable){
          Thread t=new Thread(runnable,"Atmosphere-BroadcasterConfig-" + count.getAndIncrement());
          t.setDaemon(true);
          return t;
        }
      }
);
    }
    defaultExecutorService=executorService;
    if (numberOfAsyncThread == -1) {
      asyncWriteService=Executors.newCachedThreadPool(new ThreadFactory(){
        private final AtomicInteger count=new AtomicInteger();
        @Override public Thread newThread(        final Runnable runnable){
          Thread t=new Thread(runnable,"Atmosphere-AsyncWrite-" + count.getAndIncrement());
          t.setDaemon(true);
          return t;
        }
      }
);
    }
 else {
      asyncWriteService=Executors.newFixedThreadPool(numberOfAsyncThread,new ThreadFactory(){
        private final AtomicInteger count=new AtomicInteger();
        @Override public Thread newThread(        final Runnable runnable){
          Thread t=new Thread(runnable,"Atmosphere-AsyncWrite-" + count.getAndIncrement());
          t.setDaemon(true);
          return t;
        }
      }
);
    }
    defaultAsyncWriteService=asyncWriteService;
    if (isExecutorShared) {
      config.properties().put("executorService",executorService);
      config.properties().put("asyncWriteService",asyncWriteService);
    }
  }
 else {
    executorService=(ExecutorService)config.properties().get("executorService");
    defaultExecutorService=executorService;
    asyncWriteService=(ExecutorService)config.properties().get("asyncWriteService");
    defaultAsyncWriteService=asyncWriteService;
  }
}
