{
  final AtmosphereRequest request=r.getRequest();
  final AtmosphereResponse response=r.getResponse();
  final AtmosphereHandler atmosphereHandler=(AtmosphereHandler)request.getAttribute(FrameworkConfig.ATMOSPHERE_HANDLER);
  try {
    String path=request.getPathInfo();
    if (path == null || path.length() == 0 || "/".equals(path)) {
      response.sendError(AtmosphereResponse.SC_BAD_REQUEST,"Missing SocketIO transport");
      return null;
    }
    if (path.startsWith("/")) {
      path=path.substring(1);
    }
    String[] parts=path.split("/");
    String protocol=null;
    String version=null;
    if (parts.length == 0) {
      return null;
    }
 else     if (parts.length == 1) {
      if (parts[0].length() == 1) {
        version=parts[0];
        if (!Character.isDigit(version.charAt(0))) {
          version=null;
        }
      }
 else {
        protocol=parts[0];
      }
    }
 else {
      version=parts[0];
      protocol=parts[1];
      if (!Character.isDigit(version.charAt(0))) {
        version=null;
        protocol=null;
      }
    }
    if (protocol == null && version == null) {
      return null;
    }
 else     if (protocol == null && version != null) {
      response.setStatus(200);
      SocketIOSession session=getSessionManager(version).createSession((AtmosphereResourceImpl)r,atmosphereHandler);
      response.getWriter().print(session.getSessionId() + ":" + heartbeatInterval+ ":"+ timeout+ ":"+ availableTransports);
      return Action.CANCELLED;
    }
 else     if (protocol != null && version == null) {
      version="0";
    }
    final Transport transport=transports.get(protocol + "-" + version);
    if (transport != null) {
      if (!SocketIOAtmosphereHandler.class.isAssignableFrom(atmosphereHandler.getClass())) {
        response.asyncIOWriter(new AsyncIOWriterAdapter(){
          @Override public AsyncIOWriter write(          AtmosphereResponse r,          String data) throws IOException {
            SocketIOSessionOutbound outbound=(SocketIOSessionOutbound)request.getAttribute(SocketIOAtmosphereHandler.SOCKETIO_SESSION_OUTBOUND);
            if (outbound != null) {
              outbound.sendMessage(new SocketIOPacketImpl(SocketIOPacketImpl.PacketType.MESSAGE,data));
            }
 else {
              r.getResponse().getWriter().write(data);
            }
            return this;
          }
          @Override public AsyncIOWriter write(          AtmosphereResponse r,          byte[] data) throws IOException {
            write(new String(data));
            return this;
          }
          @Override public AsyncIOWriter write(          AtmosphereResponse r,          byte[] data,          int offset,          int length) throws IOException {
            return write(new String(data,offset,length));
          }
          @Override public AsyncIOWriter flush(          AtmosphereResponse r) throws IOException {
            return this;
          }
        }
);
      }
      return transport.handle((AtmosphereResourceImpl)r,atmosphereHandler,getSessionManager(version));
    }
 else {
      logger.error("Protocol not supported : " + protocol);
    }
  }
 catch (  Exception e) {
    logger.error("",e);
  }
  return Action.CANCELLED;
}
